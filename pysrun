#!/usr/bin/env python   
"""A Python implementation of the SRUN 3000 internet tolling client.

Usage: pysrun {login|logout}

Before starting the program, a configuration file must be saved at the
path "~/.pysrun.cfg".  As of now, the path to config file is hard-coded.
This is expected to be fixed in the future.

The configuration file is used to store login credentials and run-time
options.  An example config file is provided with the default settings.

This program is in the Public Domain.  You are free to use it and modify it.


"""
import sys
import os.path
import re
import ConfigParser
import urllib
import urllib2
import platform
from socket import AF_INET, AF_INET6, inet_ntop
from ctypes import *


# Regexp for the returned "uid" used by the SRUN server.
UIDRE = re.compile(r"[0-9]+")  #FIXME: this is only a guess.

# Server error message table. This, too, is just guesses.
ERRMSG = {"username_error": "invalid username",
        "password_error": "invalid password",
        "ip_exist_error": "already authenticated",
        "online_num_error": "maximal number of online users exceeded"}


def platformis(plat):
    """Check whether plat matches the platform of the machine. The comparison
    is case-insensitive.

    """
    # we are not using sys.platform because that info was written when
    # Python is compiled, not run.  Practically this is a non-issue.
    platformid = platform.system().lower()
    return platformid.startswith(plat.lower())


# Platform-specific initialization
if platformis("linux"):
    # Linux link-layer address family
    from socket import AF_PACKET as af_link
elif platformis("freebsd"):
    # According to FreeBSD doc, this is AF_LINK.  See sys/socket.h
    # http://www.freebsd.org/doc/en/books/developers-handbook/sockets-essential-functions.html
    af_link = 18
else:
    raise NotImplementedError, "Not implemented for %s" % platform.system()


# Implementation of getifaddrs()-based MAC functions.
# Ref1: http://kbyanc.blogspot.com/2010/11/python-enumerating-ip-addresses-on.html
# Ref2: http://carnivore.it/2010/07/22/python_-_getifaddrs
class ifa_ifu_u(Union):
    _fields_ = [
            ("ifu_broadaddr", c_void_p),
            ("ifu_dstaddr", c_void_p)]


if platformis("freebsd"):
    class sockaddr(Structure):
        _fields_ = [
                ("sa_len", c_uint8),
                ("sa_family", c_uint8),
                ("sa_data", (c_uint8 * 14))]
else:
    class sockaddr(Structure):
        _fields_ = [
                ("sa_family", c_uint16),
                ("sa_data", (c_uint8 * 14))]


# AF_PACKET / Linux
class sockaddr_ll(Structure):
    _fields_ = [
            ("sll_family", c_ushort),
            ("sll_protocol", c_uint16),
            ("sll_ifindex", c_int),
            ("sll_hatype", c_short),
            ("sll_pkttype", c_uint8),
            ("sll_halen", c_uint8),
            ("sll_addr", (c_uint8 * 8))]

    def __str__(self):
        return ":".join(["%02x" % self.sll_addr[i]
            for i in range(self.sll_halen)])


# AF_LINK / BSD|OSX
class sockaddr_dl(Structure):
    _fields_ = [
            ("sdl_len", c_uint8),
            ("sdl_family", c_uint8),
            ("sdl_index", c_ushort),
            ("sdl_type", c_uint8),
            ("sdl_nlen", c_uint8),
            ("sdl_alen", c_uint8),
            ("sdl_slen", c_uint8),
            ("sdl_data", (c_uint8 * 46))]

    def __str__(self):
        assert self.sdl_len >= sizeof(sockaddr_dl)
        addrdata = self.sdl_data[self.sdl_nlen : self.sdl_nlen
                + self.sdl_alen]
        return ":".join(["%02x" % x for x in addrdata])


class ifaddrs(Structure):
    _fields_ = [
            ("ifa_next", c_void_p),
            ("ifa_name", c_char_p),
            ("ifa_flags", c_uint),
            ("ifa_addr", c_void_p),
            ("ifa_netmask", c_void_p),
            ("ifa_ifu", ifa_ifu_u),
            ("ifa_data", c_void_p)]


def getmacaddrs():
    """Returns a dictionary with each key being an interface name and
    the value being a list of corresponding MAC addresses (possibly empty), in
    textual representation.

    This function calls the platform's getifaddrs() implementation.

    """
    libc = CDLL("libc.so.6")
    ptr = c_void_p(None)
    result = libc.getifaddrs(pointer(ptr))
    if result != 0:
        return None
    ifa = ifaddrs.from_address(ptr.value)
    result = {}

    while True:
        name = ifa.ifa_name
        if name not in result:
            result[name] = []

        sa = sockaddr.from_address(ifa.ifa_addr)

        if sa.sa_family == af_link:
            if ifa.ifa_addr is not None:
                if platformis("linux"):
                    si = sockaddr_ll.from_address(ifa.ifa_addr)
                elif platformis("freebsd"):
                    si = sockaddr_dl.from_address(ifa.ifa_addr)
                addr = "%s" % si
                if addr:
                    result[name].append(addr)

        if ifa.ifa_next:
            ifa = ifaddrs.from_address(ifa.ifa_next)
        else:
            break

    libc.freeifaddrs(ptr)

    return result


def get_hwaddress(ifname):
    """Returns a text representation of the HW address of an interface."""
    # It might be possible that more than one link-layer address is associated
    # with the interface.  If this is the case, we simply return the first.
    # If there's no such interface or the interface hasMAC address,
    # we raise an RuntimeError
    macdict = getmacaddrs()
    try:
        addr = macdict[ifname][0]
    except (IndexError, KeyError):
        raise RuntimeError, "%s: Can't find address information." % ifname
    return addr


def tamper_hwaddress(hwaddress):
    # For whatever reason, we want to tamper the HW address.
    # This may just be a bug of the SRUN client, but we decide to maintain
    # maximal conformance, bug-to-bug.
    return "ff:ff:%s" % hwaddress[6:]


def read_uid(uid_path):
    """Search in the uid_path file for the uid used to end a session.  Stop and
    return on first match."""

    fh = open(uid_path, "r")
    for line in fh:
        bline = line.strip()
        if UIDRE.match(bline):
            return bline
    raise RuntimeError, "No UID found in UID file: %s" % uid_path


def write_uid(uid, uid_path):
    fh = open(uid_path, "w")
    fh.truncate(0)
    fh.write("%s\n" % uid)
    fh.close()
    return None


def do_login(address, port, postdata):
    """Performs the login action.  Blocks until receives server message or
    timeout.

    Returns the server message."""

    url = "http://%s:%s/cgi-bin/do_login" % (address, port)
    f = urllib2.urlopen(url, postdata)
    msg = f.read()
    f.close()
    return msg


def do_logout(address, port, postdata):
    """Performs the logout action and display the returned message."""

    url = "http://%s:%s/cgi-bin/do_logout" % (address, port)
    f = urllib2.urlopen(url, postdata)
    for line in f:
        # FIXME: debugging only
        print >> sys.stderr, line
    f.close()
    return None


def login(config):
    """The login sequence."""

    # Gather login data
    uname = config.get("Account", "username")
    passwd = config.get("Account", "password")
    ifname = config.get("Client", "interface")
    address = config.get("Server", "address")
    port = config.get("Server", "port")
    fname = os.path.expanduser(config.get("Session", "uidfile"))

    login_data = {"username": uname,
        "password": passwd,
        "drop": "0",
        "type": "3",
        "n": "99",
        "mac": tamper_hwaddress(get_hwaddress(ifname))}
    login_postdata = urllib.urlencode(login_data)

    # Send data and receive response.
    # Expect either uid or server exception message.
    msg = do_login(address, port, login_postdata)

    # Analyse return message.
    txt, part, tail = msg.partition("`")
    if not part:            # Message doesn't contain the sep character "`"
        raise RuntimeError, "Server return message not understood: %s" % msg

    if UIDRE.match(txt):    # We got the uid
        write_uid(txt, fname)
    else:                   # Should be exception message
        handle_server_exception(txt)
        # And leave the uid file alone, if exist

    return None


def handle_server_exception(txt):
    if txt in ERRMSG:
        # We don't raise RuntimeError, because this is something the program
        # understands.
        print >> sys.stderr, "Login error: %s." % ERRMSG[txt]
        sys.exit(1)
    else:
        raise RuntimeError, "Unhandled login error: %s." % ERRMSG[txt]


def logout(config):
    fname = os.path.expanduser(config.get("Session", "uidfile"))
    uid = read_uid(fname)

    address = config.get("Server", "address")
    port = config.get("Server", "port")

    logout_data = {"uid": uid}
    logout_postdata = urllib.urlencode(logout_data)

    do_logout(address, port, logout_postdata)

    return None


if __name__ == "__main__":
    op = sys.argv[1]
    #FIXME: this shouldn't be hard-coded.
    config_path = os.path.expanduser("~/.pysrun.cfg")
    config = ConfigParser.RawConfigParser()
    config.read(config_path)

    if op == "login":
        login(config)
    elif op == "logout":
        logout(config)
    else:
        sys.exit(2)
