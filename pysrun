#!/usr/bin/env python   
"""A Python implementation of the SRUN 3000 internet tolling client.

Usage: pysrun {login|logout}

Before starting the program, a configuration file must be saved at the
path "~/.pysrun.cfg".  As of now, the path to config file is hard-coded.
This is expected to be fixed in the future.

The configuration file is used to store login credentials and run-time
options.  An example config file is provided with the default settings.

This program is in the Public Domain.  You are free to use it and modify it.


"""
import sys
import os.path
import re
import ConfigParser
import urllib
import urllib2
import platform
from socket import AF_INET, AF_INET6, inet_ntop
from ctypes import *


def platformis(plat):
    """Check whether plat matches the platform of the machine. The comparison
    is case-insensitive.

    """
    # we are not using sys.platform because that info was written when
    # Python is compiled, not run.
    platformid = platform.system().lower()
    return platformid.startswith(plat.lower())


# Platform-specific initialization
if platformis("linux"):
    from socket import AF_PACKET    # Linux-ism link layer address family
    af_link = AF_PACKET
elif platformis("freebsd"):
    af_link = 18                    # According to FreeBSD doc, this is AF_LINK
else:
    raise NotImplementedError, "Not implemented for %s" % platform.system()


class ifa_ifu_u(Union):
    _fields_ = [
            ("ifu_broadaddr", c_void_p),
            ("ifu_dstaddr", c_void_p)]


# AF_UNKNOWN / generic
if platformis("darwin") or platformis("freebsd"):
    class sockaddr(Structure):
        _fields_ = [
                ("sa_len", c_uint8),
                ("sa_family", c_uint8),
                ("sa_data", (c_uint8 * 14))]
else:
    class sockaddr(Structure):
        _fields_ = [
                ("sa_family", c_uint16),
                ("sa_data", (c_uint8 * 14))]


# AF_PACKET / Linux
class sockaddr_ll(Structure):
    _fields_ = [
            ("sll_family", c_ushort),
            ("sll_protocol", c_uint16),
            ("sll_ifindex", c_int),
            ("sll_hatype", c_short),
            ("sll_pkttype", c_uint8),
            ("sll_halen", c_uint8),
            ("sll_addr", (c_uint8 * 8))]

    def __str__(self):
        return ":".join(["%02x" % self.sll_addr[i]
            for i in range(self.sll_halen)])


# AF_LINK / BSD|OSX
class sockaddr_dl(Structure):
    _fields_ = [
            ("sdl_len", c_uint8),
            ("sdl_family", c_uint8),
            ("sdl_index", c_ushort),
            ("sdl_type", c_uint8),
            ("sdl_nlen", c_uint8),
            ("sdl_alen", c_uint8),
            ("sdl_slen", c_uint8),
            ("sdl_data", (c_uint8 * 46))]

    def __str__(self):
        assert self.sdl_len >= sizeof(sockaddr_dl)
        addrdata = self.sdl_data[self.sdl_nlen : self.sdl_nlen
                + self.sdl_alen]
        return ":".join(["%02x" % x for x in addrdata])


class ifaddrs(Structure):
    _fields_ = [
            ("ifa_next", c_void_p),
            ("ifa_name", c_char_p),
            ("ifa_flags", c_uint),
            ("ifa_addr", c_void_p),
            ("ifa_netmask", c_void_p),
            ("ifa_ifu", ifa_ifu_u),
            ("ifa_data", c_void_p)]


def getmacaddrs():
    """Returns a dictionary with each key being an interface name and
    the value being a list of corresponding MAC addresses (possibly empty), in
    textual representation.

    This function calls the platform's getifaddrs() implementation.

    """
    libc = CDLL("libc.so.6")
    ptr = c_void_p(None)
    result = libc.getifaddrs(pointer(ptr))
    if result != 0:
        return None
    ifa = ifaddrs.from_address(ptr.value)
    result = {}

    while True:
        name = ifa.ifa_name
        if name not in result:
            result[name] = []

        sa = sockaddr.from_address(ifa.ifa_addr)

        if sa.sa_family == af_link:
            if ifa.ifa_addr is not None:
                if platformis("linux"):
                    si = sockaddr_ll.from_address(ifa.ifa_addr)
                elif platformis("freebsd"):
                    si = sockaddr_dl.from_address(ifa.ifa_addr)
                addr = "%s" % si
                if addr:
                    result[name].append(addr)

        if ifa.ifa_next:
            ifa = ifaddrs.from_address(ifa.ifa_next)
        else:
            break

    libc.freeifaddrs(ptr)

    return result


# Regexp for the returned "uid" used by the SRUN server.
UIDRE = re.compile(r"[0-9a-zA-Z]+")  #FIXME: this is only a guess.


def get_hwaddress(ifname):
    """Returns a text representation of the HW address of an interface."""
    # It might be possible that more than one link-layer address is associated
    # with the interface.  If this is the case, we simply return the first.
    # If there's no such interface or the interface hasMAC address,
    # we raise an RuntimeError
    macdict = getmacaddrs()
    try:
        addr = macdict[ifname][0]
    except (IndexError, KeyError):
        raise RuntimeError, "%s: Can't find address information." % ifname
    return addr


def tamper_hwaddress(hwaddress):
    # For whatever reason, we want to tamper the HW address.
    # This may just be a bug of the SRUN client, but we decide to maintain
    # maximal conformance, bug-to-bug.
    return "ff:ff:%s" % hwaddress[6:]


def read_uid(uid_path):
    """Search in the uid_path file for the uid used to end a session.  Stop and
    return on first match."""

    fh = open(uid_path, "r")
    for line in fh:
        bline = line.strip()
        if UIDRE.match(bline):
            return bline
    raise RuntimeError, "No UID found in UID file: %s" % uid_path


def write_uid(uid, uid_path):
    fh = open(uid_path, "w")
    fh.truncate(0)
    fh.write("%s\n" % uid)
    fh.close()
    return None


def do_login(address, port, postdata):
    """Performs the login action.  Returns the uid."""

    url = "http://%s:%s/cgi-bin/do_login" % (address, port)
    f = urllib2.urlopen(url, postdata)
    uid = UIDRE.match(f.read()).group()
    return uid


def do_logout(address, port, postdata):
    """Performs the logout action and display the returned message."""

    url = "http://%s:%s/cgi-bin/do_logout" % (address, port)
    f = urllib2.urlopen(url, postdata)
    for line in f:
        print line
    return None


def login(config):
    uname = config.get("Account", "username")
    passwd = config.get("Account", "password")
    ifname = config.get("Client", "interface")
    address = config.get("Server", "address")
    port = config.get("Server", "port")
    fname = os.path.expanduser(config.get("Session", "uidfile"))

    login_data = {"username": uname,
        "password": passwd,
        "drop": "0",
        "type": "3",
        "n": "99",
        "mac": tamper_hwaddress(get_hwaddress(ifname))}
    login_postdata = urllib.urlencode(login_data)

    uid = do_login(address, port, login_postdata)
    write_uid(uid, fname)

    return None


def logout(config):
    fname = os.path.expanduser(config.get("Session", "uidfile"))
    uid = read_uid(fname)

    address = config.get("Server", "address")
    port = config.get("Server", "port")

    logout_data = {"uid": uid}
    logout_postdata = urllib.urlencode(logout_data)

    do_logout(address, port, logout_postdata)

    return None


if __name__ == "__main__":
    op = sys.argv[1]
    #FIXME: this shouldn't be hard-coded.
    config_path = os.path.expanduser("~/.pysrun.cfg")
    config = ConfigParser.RawConfigParser()
    config.read(config_path)

    if op == "login":
        login(config)
    elif op == "logout":
        logout(config)
    else:
        sys.exit(2)
